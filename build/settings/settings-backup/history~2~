[search.directory]
/media/mrdragan/Ubuntu/myCSU/cs510/p4/cs510mossetracker/src/
[vfs.browser.path]
/media/mrdragan/Ubuntu/myCSU/cs515/a1/temp
/media/mrdragan/Ubuntu/myCSU/cs515/a1
/media/mrdragan/Ubuntu/myCSU/cs515
/media/mrdragan/Ubuntu/myCSU
/media/mrdragan/Ubuntu/myCSU/cs510/p4/cs510mossetracker/src
/media/mrdragan/Ubuntu/myCSU/cs510/p4/cs510mossetracker
/media/mrdragan/Ubuntu/myCSU/cs510/p4
/media/mrdragan/Ubuntu/myCSU/cs510
/media/mrdragan/Ubuntu/myCSU/cs515/a1/cs515-s19-reNo-jedit
[find]
wait
namespace
[vfs.browser.filter]
*\[^~#\]
[search.filter]
*.cpp
[action]
backspace
select-prev-line
next-char
prev-line
save
paste
copy
select-prev-page
insert-newline-indent
next-line
prev-char
combined-options
plugin-options
plugin-manager
new-file
about
undo
cut
select-marker
collapse-fold
[clipboard]
\\documentclass{article}\n\\usepackage\[utf8\]{inputenc}\n\n\\title{jEdit bugs and features}\n\\author{Ben Sattelberg and Matt Dragan}\n\\date{Team reNo}\n\n\\begin{document}\n\n\\maketitle\n\n\\section{Bug: }\n\n\\includegraphics\[draft, width=\\textwidth\]{correctBehavior.png}\n\n\\includegraphics\[draft, width=\\textwidth\]{wrongBehavior.png}\n\n\\includegraphics\[draft, width=\\textwidth\]{stacktrace.png}\n\n\\section{Feature request: Vim keybindings}\n\nIn addition to support for keymaps such as Emacs, Mac OS X, and jEdit, allow support for Vim binds.\n\n\\includegraphics\[width=\\textwidth\]{mockUp.png}\n\n\\section{Feature request: Allow more customization of file name}\n\nRather than only allowing the incremented variable to be the first character, allow it to be the last character.\n\n\\end{document}\n\n\n\n\n\nAaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
\\documentclass{article}\n\\usepackage\[utf8\]{inputenc}\n\n\\title{jEdit bugs and features}\n\\author{Ben Sattelberg and Matt Dragan}\n\\date{Team reNo}\n\n\\begin{document}\n\n\\maketitle\n\n\\section{Bug: }\n\n\\includegraphics\[draft, width=\\textwidth\]{correctBehavior.png}\n\n\\includegraphics\[draft, width=\\textwidth\]{wrongBehavior.png}\n\n\\includegraphics\[draft, width=\\textwidth\]{stacktrace.png}\n\n\\section{Feature request: Vim keybindings}\n\nIn addition to support for keymaps such as Emacs, Mac OS X, and jEdit, allow support for Vim binds.\n\n\\includegraphics\[width=\\textwidth\]{mockUp.png}\n\n\\section{Feature request: Allow more customization of file name}\n\nRather than only allowing the incremented variable to be the first character, allow it to be the last character.\n\n\\end{document}\n
#include \"opencv2/objdetect/objdetect.hpp\"\n#include \"opencv2/imgcodecs.hpp\"\n#include \"opencv2/imgproc.hpp\"\n#include \"opencv2/videoio.hpp\"\n#include <opencv2/highgui.hpp>\n#include <opencv2/video.hpp>\n#include <opencv2/bgsegm.hpp>\n#include <opencv2/tracking.hpp>\n#include <opencv2/features2d.hpp>\n#include <opencv2/xfeatures2d.hpp>\n#include <opencv2/core.hpp>\n#include <opencv2/ml.hpp>\n\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <random>\n#include <ctime>\n#include <fstream>\n\n#include \"trackerMOSSE.h\"\n\nusing namespace std;\nusing namespace cv;\nusing namespace cv::xfeatures2d;\nusing namespace cv::ml;\n\nenum BigIm{\n  VIDEO, GOAL, EXACT, ASEF, EDGES, CORRELATION\n};\n\nconst string fileName = \"data/recognitionData.csv\";\n// Global vars\nint waitVal = 1;\nstring mainWindowName = \"Main window\";\nstring classLabel = \"\";\nBigIm largest = VIDEO;\nbool isFirst = true;\nBigIm largest = VIDEO;\n\nunsigned int numPerturbations = 20;\n\nMat frame;\nint fri = 0;\nvector<Mat> frames;\n\ndouble goalSDev = 0.05;\n\nRect goalArea;\nbool firstSet = false;\nbool secondSet = false;\nbool buttonPushed = false;\nbool fromFile = true;\n\ntrackerMOSSE tracker(numPerturbations);\n\nMat fgMaskMOG2;\nPtr<BackgroundSubtractor> pMOG2;\n\nKalmanFilter KF(4, 2, 0);\n\nint fps;\n\n// for feature detection\nMat roi_keypoints;\nvector<KeyPoint> keypoints;\nconst int hessian = 500;\n\n// for recognition\nPtr<KNearest> knn = KNearest::create();\nPtr<TrainData> trainingData;\n\n// Headers\nvoid frameDisplay();\nvoid switchWaitVal(int state, void* data);\nvoid draw();\nMat getFeatureVectors(int, void*);\nint handleNames(vector<string> &classNames, string newClass);\nstring getCorrectClassName(const vector<string> &classNames, const Mat &predicted);\nMat combinePrevPredictions(vector<Mat> &results);\nstring getLabel();\nbool readData(Mat & y, Mat & x, vector<string> &allClasses);\nvoid writeData(Mat & y, Mat & x, vector<string> &allClasses);\nvoid parseLine(vector<string> &classNames, vector<vector<float>> &inputData, string& line, int index);\ndouble l2Norm(const Mat &one, const Mat &two);\nvoid removeSimilarDescriptors(Mat &newDescriptors, Mat &newLabels, Mat &descriptors, Mat &Labels);\nbool isEmpty(ifstream &infile);\nbool remakeBox = false;\n\n\nMat preprocessInput(const Mat & input);\nMat sobelDetect(const Mat& in);\n\nvoid mouseCallBackFunc(int event, int x, int y, int flags, void* userdata) {\n  if(event == EVENT_LBUTTONDOWN) {\n    if(x > frame.cols - 60 and x < frame.cols - 10 and y > frame.rows - 60 and y < frame.rows - 0) {\n      buttonPushed = !buttonPushed;\n    }\n    if(x > frame.cols - 120 and x < frame.cols - 70 and y > frame.rows - 60 and y < frame.rows - 0) {\n      remakeBox = true;\n    }\n    // Left\n    if(x > frame.cols && x < frame.cols*1.5) {\n      if(y < frame.rows/2) {\n        largest = VIDEO;\n        draw();\n      }\n      else{\n        largest = EDGES;\n        draw();\n      }\n    }\n    // Middle\n    else if(x > frame.cols*1.5 && x < frame.cols*2) {\n      if(y < frame.rows/2) {\n        largest = CORRELATION;\n        draw();\n      }\n      else{\n        largest = ASEF;\n        draw();\n      }\n    }\n    // // Right\n    // else if(x > frame.cols*2) {\n    //   if(y < frame.rows/2) {\n    //     largest = GOAL;\n    //     draw();\n    //   }\n    //   else{\n    //     largest = CORRELATION;\n    //     draw();\n    //   }\n    // }\n  }\n}\n\nvoid firstClick(int event, int x, int y, int flags, void* userdata) {\n  if(event == EVENT_LBUTTONDOWN) {\n    goalArea.x = x;\n    goalArea.y = y;\n    firstSet = true;\n  }\n}\n\nMat tempFrame;\n\nvoid secondClick(int event, int x, int y, int flags, void* userdata) {\n\n  int size = max(abs(x - goalArea.x), abs(y - goalArea.y));\n  // int maxX = max(x, goalArea.x);\n  // int maxY = max(y, goalArea.y);\n  // int minX = min(x, goalArea.x);\n  // int minY = min(y, goalArea.y);\n\n  if(event == EVENT_LBUTTONDOWN) {\n    //goalArea.x = minX;\n    //goalArea.y = minY;\n    goalArea.width = 2*size;\n    goalArea.height = 2*size;\n    goalArea.width = max(goalArea.width, goalArea.height);\n    goalArea.height = goalArea.width;\n    goalArea.x -= goalArea.width/2;\n    goalArea.y -= goalArea.height/2;\n\n    secondSet = true;\n  }\n  else {\n    rectangle(frame, Point(goalArea.x -size, goalArea.y - size), Point(goalArea.x + size, goalArea.y + size ), Scalar(0, 0, 255));\n    imshow(\"ROI select\", frame);\n    if(fromFile) {\n      frame = tempFrame.clone();\n    }\n  }\n}\n\nvoid setupKalmanFilter(KalmanFilter & kal) {\n  kal.transitionMatrix = (Mat_<float>(4, 4) << 1, 0, 1, 0,\n                                              0, 1, 0, 1,\n                                              0, 0, 1, 0,\n                                              0, 0, 0, 1);\n  kal.statePost.at<float>(0) = frame.rows/2;\n  kal.statePost.at<float>(1) = frame.cols/2;\n  kal.statePost.at<float>(2) = 0;\n  kal.statePost.at<float>(3) = 0;\n  // KF.statePost.at<float>(4) = 0;\n  // KF.statePost.at<float>(5) = 0;\n  setIdentity(kal.measurementMatrix);\n  setIdentity(kal.processNoiseCov, Scalar::all(1e-4));\n  setIdentity(kal.measurementNoiseCov, Scalar::all(1e1));\n  setIdentity(kal.errorCovPost, Scalar::all(.1));\n}\n\nMat boundingRectangle(const Mat &frame, const Mat &points, bool & done) {\n  static bool didSetupKalmanFilter = false;\n  static KalmanFilter kal(4, 2, 0);\n  static Point center(0, 0);\n  static int size = 0;\n  static int count = 0;\n\n  if(!didSetupKalmanFilter) {\n    didSetupKalmanFilter = true;\n    setupKalmanFilter(kal);\n  }\n\n  Mat out = frame.clone();\n  Rect exterior(0, 0, out.cols, out.rows);\n  vector<Point> locations;\n  Mat bird;\n  // Find the location of nonblack pixels\n  findNonZero(points, locations);\n  findNonZero(points, bird);\n\n  // Find the maximum and minimum nonblack pixels\n  int highX = 0;\n  int highY = 0;\n  int lowX = points.cols;\n  int lowY = points.rows;\n\n  for(Point point : locations) {\n    highX = max(highX, point.x);\n    lowX =  min(lowX, point.x);\n    highY = max(highY, point.y);\n    lowY =  min(lowY, point.y);\n  }\n\n  if(size == 0 && (highX < lowX || highY < lowY)) {\n    return out;\n  }\n\n  if(highX - lowX > 0 && highY - lowY > 0) {\n    center.x = (highX - lowX)/2 + lowX;\n    center.y = (highY - lowY)/2 + lowY;\n    size = max((int) round(0.8*size), max(highX -lowX, highY - lowY));\n    count = 0;\n    frames.clear();\n  }\n  else {\n    frames.push_back(frame);\n    if(++count > 30) {\n      done = true;\n      return out;\n    }\n  }\n\n  Mat prediction = kal.predict();\n  Mat measurement = (Mat_<float>(2, 1) << center.x, center.y);\n  Mat estimated = kal.correct(measurement);\n  if((estimated.at<float>(0) == 0 && estimated.at<float>(1) == 0)) {\n    setupKalmanFilter(kal);\n  }\n  else if(count == 0){\n    center.x = estimated.at<float>(0);\n    center.y = estimated.at<float>(1);\n  }\n  circle(out, center, 7, Scalar(255, 0, 0), -1);\n\n  // Do not extend past left or right edge\n  if(center.x - size/2 < 0) {\n    size = 2*center.x;\n  }\n  if(center.x + size/2 > out.rows) {\n    size = 2*(out.rows - center.x);\n  }\n  if(center.y - size/2 < 0) {\n    size = 2*center.y;\n  }\n  if(center.y + size/2 > out.cols) {\n    size = 2*(out.cols - center.y);\n  }\n\n  goalArea.x = center.x;\n  goalArea.y = center.y;\n  goalArea.width = size;\n  goalArea.height = size;\n\n  // rectangle(\n  //   out,\n  //   Point(lowX, lowY),\n  //   Point(highX, highY),\n  //   Scalar(0, 255, 0)\n  // );\n  return out;\n}\n\nvoid drawButton(Mat thing) {\n\n  if(buttonPushed){\n    string text = \"finish\";\n    int fontFace = FONT_HERSHEY_PLAIN;\n    double fontScale = 1.0;\n    int thickness = 1;\n    int baseline = 0;\n\n    Size textSize = getTextSize(text, fontFace, fontScale, thickness, &baseline);\n\n    Point textOrg(frame.cols -60 + (50-textSize.width)/2, frame.rows-60 + (50+textSize.height)/2);\n\n    thickness = 3;\n    textSize = getTextSize(text, fontFace, fontScale, thickness, &baseline);\n    Point textOrg2(frame.cols -60 + (50-textSize.width)/2, frame.rows-60 + (50+textSize.height)/2);\n\n    rectangle(thing, Point(frame.cols - 60, frame.rows - 60), Point(frame.cols-10, frame.rows-10), Scalar(255, 0, 0), -1);\n    rectangle(thing, Point(frame.cols - 60, frame.rows - 60), Point(frame.cols-10, frame.rows-10), Scalar(0, 0, 0), 5);\n    putText(thing, text, textOrg2, fontFace, fontScale, Scalar(0, 0, 0), 3, 8);\n    putText(thing, text, textOrg, fontFace, fontScale, Scalar(255, 255, 255), 1, 8);\n\n  }\n  else {\n    string text = \"train\";\n    int fontFace = FONT_HERSHEY_PLAIN;\n    double fontScale = 1.0;\n    int thickness = 1;\n    int baseline = 0;\n\n    Size textSize = getTextSize(text, fontFace, fontScale, thickness, &baseline);\n\n    Point textOrg(frame.cols -60 + (50-textSize.width)/2, frame.rows-60 + (50+textSize.height)/2);\n\n    textSize = getTextSize(text, fontFace, fontScale, 3, &baseline);\n    Point textOrg2(frame.cols -60 + (50-textSize.width)/2, frame.rows-60 + (50+textSize.height)/2);\n\n    rectangle(thing, Point(frame.cols - 60, frame.rows - 60), Point(frame.cols-10, frame.rows-10), Scalar(255, 0, 0), -1);\n    rectangle(thing, Point(frame.cols - 60, frame.rows - 60), Point(frame.cols-10, frame.rows-10), Scalar(0, 0, 0), 1);\n    putText(thing, text, textOrg2, fontFace, fontScale, Scalar(0, 0, 0), 3, 8);\n    putText(thing, text, textOrg, fontFace, fontScale, Scalar(255, 255, 255), 1, 8);\n  }\n  string text = \"reset\";\n  int fontFace = FONT_HERSHEY_PLAIN;\n  double fontScale = 1.0;\n  int thickness = 1;\n  int baseline = 0;\n\n  Size textSize = getTextSize(text, fontFace, fontScale, thickness, &baseline);\n\n  Point textOrg(frame.cols -120 + (50-textSize.width)/2, frame.rows-60 + (50+textSize.height)/2);\n\n  // textSize = getTextSize(text, fontFace, fontScale, 4, &baseline);\n  // Point textOrg2(frame.cols -120 + (50-textSize.width)/2, frame.rows-60 + (50+textSize.height)/2);\n\n  rectangle(thing, Point(frame.cols - 120, frame.rows - 60), Point(frame.cols-70, frame.rows-10), Scalar(0, 0, 254), -1);\n  rectangle(thing, Point(frame.cols - 120, frame.rows - 60), Point(frame.cols-70, frame.rows-10), Scalar(0, 0, 0), 1);\n  //putText(thing, text, textOrg2, fontFace, fontScale, Scalar(0, 0, 0), 3, 8);\n  putText(thing, text, textOrg, fontFace, fontScale, Scalar(255, 255, 255), 1, 8);\n}\n\nvoid makeBoundingBox(VideoCapture & cap, Rect & R) {\n  // If from a file have the user draw a box\n  if(true) {\n    tempFrame = frame.clone();\n    imshow(\"ROI select\", frame);\n    setMouseCallback(\"ROI select\", firstClick, NULL);\n\n    while(!firstSet) {\n      if(!fromFile) {\n        cap.read(frame);\n        frame = frame(R);\n        flip(frame, frame, 1);\n      }\n      imshow(\"ROI select\", frame);\n      waitKey(1);\n    }\n    goalArea.width = 128;\n    goalArea.height = 128;\n    goalArea.x -= goalArea.width/2;\n    goalArea.y -= goalArea.height/2;\n    // setMouseCallback(\"ROI select\", secondClick, NULL);\n    // while(!secondSet) {\n    //   if(!fromFile) {\n    //     cap.read(frame);\n    //     frame = frame(R);\n    //     flip(frame, frame, 1);\n    //   }\n    //   waitKey(1);\n    // }\n    destroyWindow(\"ROI select\");\n  } // Othewise detect motion\n  else {\n    pMOG2 = createBackgroundSubtractorMOG2();\n\n    Mat grad;\n    Mat thresh;\n    Mat outline;\n    //Mat cosWindow;\n    //createHanningWindow(cosWindow, frame.size(), CV_32F);\n    bool isDone = false;\n\n    Mat temp2 = Mat::zeros(frame.size(), CV_8U);\n\n    while(true) {\n      cap.read(frame);\n      frame = frame(R);\n      flip(frame, frame, 1);\n      cvtColor(frame, grad, CV_BGR2GRAY);\n      grad.convertTo(grad, CV_32F);\n      log(grad + 1, grad);\n      normalize(grad, grad, 1, 0, NORM_L2);\n      normalize(grad, grad, 0, 255, CV_MINMAX);\n      // grad = sobelDetect(frame);\n      // grad.convertTo(grad, CV_32F);\n\n      pMOG2->apply(grad, fgMaskMOG2);\n      Mat temp;\n      int dilation_size = 7;\n      Mat element = getStructuringElement(MORPH_ELLIPSE, Size(2*dilation_size + 1, 2*dilation_size+1), Point(dilation_size, dilation_size));\n      morphologyEx(fgMaskMOG2, temp, MORPH_OPEN, element);\n\n      frame = boundingRectangle(frame, temp, isDone);\n      if(isDone) {\n        goalArea.width = 128;\n        goalArea.height = 128;\n\n        goalArea.x = goalArea.x - goalArea.width/2;\n        goalArea.y = goalArea.y - goalArea.height/2;\n\n        // for(unsigned int i = 20; i < frames.size(); ++i) {\n        //   Mat grad = preprocessInput(frame);\n        //   Mat temp = grad(goalArea).clone();\n        //   Mat cosWindow;\n        //   createHanningWindow(cosWindow, temp.size(), CV_32F);\n        //   multiply(temp, cosWindow, temp);\n        //   tracker.updateFilter(temp, Point2f(goalArea.width/2,goalArea.height/2), goalSDev);\n        // }\n\n        destroyWindow(\"frame\");\n        break;\n      }\n      imshow(\"frame\", frame);\n\n      waitKey(1);\n    }\n  }\n}\n// Functions\nint main(int argc, const char** argv) {\n  VideoCapture cap;\n  vector<string> classNames;\n  vector<Mat> prevFrames;\n  vector<Mat> descriptors;\n  string className;\n  Mat descriptor, x, y;\n  int classNumber;\n  bool trainedOnce = false;\n  bool historicButton = false;\n  bool couldRead = false;\n\n  knn -> setIsClassifier(true);\n  knn -> setAlgorithmType(KNearest::Types::BRUTE_FORCE);\n  knn -> setDefaultK(4);\n\n\n  if( argc != 2) {\n    cap.open(0);\n    cap.set(CV_CAP_PROP_FRAME_WIDTH, 100000000);\n    cap.set(CV_CAP_PROP_FRAME_HEIGHT,100000000);\n    fromFile = false;\n  }\n  else {\n    cap.open(argv\[1\]);\n  }\n\n  if (!cap.isOpened()) {\n    cout << \"Cannot open the video file\" << endl;\n    return -1;\n  }\n\n  if(fromFile) {\n    bool success = true;\n    while(success) {\n      Mat temp;\n      success = cap.read(temp);\n      if(success) {\n        frames.push_back(temp);\n      }\n    }\n  }\n\n  Rect R;\n  if(fromFile) {\n    int resolution = 720; // images will be resolution x resolution pixels\n    Rect temp(frames\[0\].cols/2 - resolution/2, frames\[0\].rows/2 - resolution/2, resolution, resolution);\n    R = temp;\n    frame = frames\[0\](R);\n  }\n  else {\n    cap.read(frame);\n    // Wait then read to avoid webcam startup issues\n    waitKey(100);\n    cap.read(frame);\n    // Make the input square\n    if(frame.rows < frame.cols) {\n      Rect temp((frame.cols-frame.rows)/2.0,0, frame.rows, frame.rows);\n      //Rect temp(0, 0, frame.cols, frame.rows);\n      R = temp;\n    }\n    else {\n      Rect temp(0,(frame.rows-frame.cols)/2.0, frame.cols, frame.cols);\n      //Rect temp(0, 0, frame.cols, frame.rows);\n      R = temp;\n    }\n    frame = frame(R);\n    flip(frame, frame, 1);\n  }\n\n\n  makeBoundingBox(cap, R);\n  // KF.transitionMatrix = (Mat_<float>(6, 6) << 1, 0, 1, 0, 0, 0,\n  //                                             0, 1, 0, 1, 0, 0,\n  //                                             0, 0, 1, 0, 1, 0,\n  //                                             0, 0, 0, 1, 0, 1,\n  //                                             0, 0, 0, 0, 1, 0,\n  //                                             0, 0, 0, 0, 0, 1);\n\n  KF.transitionMatrix = (Mat_<float>(4, 4) << 1, 0, 1, 0,\n                                              0, 1, 0, 1,\n                                              0, 0, 1, 0,\n                                              0, 0, 0, 1);\n  KF.statePost.at<float>(0) = goalArea.x;// + goalArea.width/2;\n  KF.statePost.at<float>(1) = goalArea.y;// + goalArea.height/2;\n  KF.statePost.at<float>(2) = 0;\n  KF.statePost.at<float>(3) = 0;\n  // KF.statePost.at<float>(4) = 0;\n  // KF.statePost.at<float>(5) = 0;\n  setIdentity(KF.measurementMatrix);\n  setIdentity(KF.processNoiseCov, Scalar::all(1e-4));\n  setIdentity(KF.measurementNoiseCov, Scalar::all(1e-1));\n  setIdentity(KF.errorCovPost, Scalar::all(.1));\n\n  namedWindow(mainWindowName, CV_WINDOW_AUTOSIZE);\n  setMouseCallback(mainWindowName, mouseCallBackFunc, NULL);\n\n  int step = 1;\n\n  couldRead = readData(y, x, classNames);\n  cout << couldRead << endl;\n  if(couldRead)\n  {\n    trainingData = TrainData::create(x, SampleTypes::ROW_SAMPLE, y);\n    knn -> train(trainingData, true);\n    trainedOnce = true;\n  }\n  else\n  {\n    x = Mat(0, 64, CV_32FC1);\n    y = Mat(0, 1, CV_32FC1);\n  }\n  std::clock_t start = std::clock();\n\n  while(true) {\n    fps = ((double)(CLOCKS_PER_SEC)/(std::clock() - start));\n    start = std::clock();\n    if(fromFile) {\n      if (fri >= (int) frames.size()) {\n        step = -step;\n        fri = frames.size() - 2;\n      }\n      else if(fri < 0) {\n        step = -step;\n        fri = 1;\n      }\n      frame = frames\[fri\](R);\n    }\n\n    if(remakeBox) {\n      tracker.isInitialized = false;\n      firstSet = false;\n      secondSet = false;\n      makeBoundingBox(cap, R);\n      remakeBox = false;\n    }\n\n    descriptor = getFeatureVectors(0,0);\n\n    if(buttonPushed && descriptor.rows > 0)\n    {\n      //descriptor = getFeatureVectors(0,0);\n      descriptors.push_back(descriptor);\n      classLabel = \"Training\";\n    }\n    else if(!buttonPushed && historicButton)\n    {\n      className = getLabel();\n      vconcat(descriptors, descriptor);\n      classNumber = handleNames(classNames, className);\n      Mat trainingLabels(descriptor.rows, 1, CV_32F);\n      for(int i = 0; i < descriptor.rows; i++)\n      {\n        trainingLabels.at<float>(i, 0) = classNumber;\n      }\n\n      removeSimilarDescriptors(descriptor, trainingLabels, x, y);\n\n      writeData(trainingLabels, descriptor, classNames);\n      trainingData = TrainData::create(descriptor, SampleTypes::ROW_SAMPLE, trainingLabels);\n      knn -> train(trainingData, true);\n      trainedOnce = true;\n\n      firstSet = false;\n      secondSet = false;\n      tracker.isInitialized = false;\n      makeBoundingBox(cap, R);\n    }\n    else\n    {\n      //descriptor = getFeatureVectors(0,0);\n      if(trainedOnce && descriptor.rows > 0)\n      {\n        Mat matResults;\n        knn -> findNearest(descriptor, knn -> getDefaultK(), matResults);\n        prevFrames.insert(prevFrames.begin(), matResults);\n        if(prevFrames.size() == 10)\n        {\n          prevFrames.pop_back();\n        }\n        vconcat(prevFrames, matResults);\n\t      classLabel = getCorrectClassName(classNames, matResults);\n       // putText(frame, name, Point2f(5, 60), FONT_HERSHEY_COMPLEX_SMALL, 1.5, Scalar(196,0 , 0));\n      }\n    }\n    historicButton = buttonPushed;\n\n    frameDisplay();\n\n    if(fromFile) {\n      label:\n      char keyboardInput = (char)waitKey(waitVal);\n      if (keyboardInput == 27) {\n        break;\n      }\n      else if (keyboardInput == \' \') {\n        switchWaitVal(0, NULL);\n      }\n      else if (keyboardInput == \',\' && waitVal == 0) {\n        fri -= step;\n      }\n      else if(keyboardInput == \'.\' && waitVal == 0) {\n        fri += step;\n      }\n      else if(waitVal == 0){\n        goto label;\n      }\n      else {\n        fri += step;\n      }\n    }\n    else {\n      char keyboardInput = (char) waitKey(waitVal);\n      if (keyboardInput == 27) {\n        break;\n      }\n      else if (keyboardInput == \' \') {\n        switchWaitVal(0, NULL);\n      }\n      ++fri;\n      cap.read(frame);\n      frame = frame(R);\n      flip(frame, frame, 1);\n    }\n  }\n  return 0;\n}\n\nvoid switchWaitVal(int state, void* data) {\n  if(waitVal != 0) {\n    waitVal = 0;\n  }\n  else {\n    waitVal = 1;\n  }\n}\n\nMat sobelDetect(const Mat& in) {\n  // Find edges\n  int scale = 1;\n  int delta = 0;\n  int ddepth = CV_32F;\n  Mat grayImage;\n  cvtColor(in, grayImage, CV_BGR2GRAY);\n  Mat grad_x, grad_y;\n  Mat abs_grad_x, abs_grad_y;\n  Mat grad;\n  // x gradient\n  Sobel(grayImage, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT);\n  convertScaleAbs(grad_x, abs_grad_x);\n  // y gradient\n  Sobel(grayImage, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT);\n  convertScaleAbs(grad_y, abs_grad_y);\n  // Find average (less accurate than sum of squares)\n  addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad);\n\n  return grad;\n}\n\n// From https://stackoverflow.com/questions/10167534/how-to-find-out-what-type-of-a-mat-object-is-with-mattype-in-opencv\n// User Octopus\'s response\nstd::string type2str(int type) {\n  std::string r;\n\n  uchar depth = type & CV_MAT_DEPTH_MASK;\n  uchar chans = 1 + (type >> CV_CN_SHIFT);\n\n  switch ( depth ) {\n    case CV_8U:  r = \"8U\"; break;\n    case CV_8S:  r = \"8S\"; break;\n    case CV_16U: r = \"16U\"; break;\n    case CV_16S: r = \"16S\"; break;\n    case CV_32S: r = \"32S\"; break;\n    case CV_32F: r = \"32F\"; break;\n    case CV_64F: r = \"64F\"; break;\n    default:     r = \"User\"; break;\n  }\n\n  r += \"C\";\n  r += (chans+\'0\');\n\n  return r;\n}\n\nMat grad, correlationResult, average, h, goal;\n\nMat preprocessInput(const Mat &frame) {\n  // Do some processing on the frame to make it useable\n  if(fromFile) {\n    // If this is from a file, do the Sobel edge detection\n    grad = sobelDetect(frame);\n    grad.convertTo(grad, CV_32F);\n  }\n  else {\n    // If this is from the webcam, make it gray, take the logarithm\n    // (for illumination), then normalize\n    cvtColor(frame, grad, CV_BGR2GRAY);\n    grad.convertTo(grad, CV_32F);\n    log(grad + 1, grad);\n    normalize(grad, grad, 1, 0, NORM_L2);\n  }\n  return grad;\n}\n\nvoid update() {\n  grad = preprocessInput(frame);\n  Point2f birdLoc(goalArea.x + goalArea.width/2, goalArea.y + goalArea.height/2);\n\n  goal = get2DGaussianAtPoint(birdLoc, frame.rows, frame.cols, goalSDev);\n\n  if(tracker.isInitialized == false) {\n    //tracker.updateFilter(grad, birdLoc, goalSDev);\n\n    Mat temp = grad(goalArea).clone();\n    Mat cosWindow;\n    createHanningWindow(cosWindow, temp.size(), CV_32F);\n    multiply(temp, cosWindow, temp);\n    //tracker.updateFilter(temp, Point2f(goalArea.width/2, goalArea.height/2), goalSDev);\n    tracker.updateFilter(grad, goalArea, birdLoc, goalSDev);\n  }\n\n\n  correlationResult = tracker.applyFilter(grad(goalArea));\n  average = tracker.getFilter();\n  h = tracker.getExactFilter();\n\n  // Get the new goal location\n  Point maxLoc = tracker.filterLoc(grad(goalArea));\n\n  goalArea.x = maxLoc.x + goalArea.x - goalArea.width/2;\n  goalArea.y = maxLoc.y + goalArea.y - goalArea.height/2;\n\n  // Mat prediction = KF.predict();\n  // Mat measurement = (Mat_<float>(2, 1) << goalArea.x, goalArea.y);\n  // Mat estimated = KF.correct(measurement);\n  // goalArea.x = estimated.at<float>(0);\n  // goalArea.y = estimated.at<float>(1);\n\n  goalArea.x = min(max(0, goalArea.x), frame.cols - goalArea.width);\n  goalArea.y = min(max(0, goalArea.y), frame.rows - goalArea.height);\n\n  //tracker.updateFilter(grad, maxLoc, goalSDev);\n\n  Mat temp = grad(goalArea).clone();\n  Mat cosWindow;\n  createHanningWindow(cosWindow, temp.size(), CV_32F);\n  multiply(temp, cosWindow, temp);\n  //tracker.updateFilter(temp, Point2f(goalArea.width/2, goalArea.height/2), goalSDev);\n  tracker.updateFilter(grad, goalArea, birdLoc, goalSDev);\n}\n\nvoid draw() {\n  // Set the title of the window\n  char window_name \[128\];\n  sprintf(window_name, \"Play back video: frame %d\", fri);\n  setWindowTitle(mainWindowName, window_name);\n\n  Mat full(frame.rows, frame.cols*2, CV_32FC3);\n  Rect main(0, 0, frame.rows, frame.cols);\n  Rect UL(frame.cols, 0, frame.cols/2, frame.rows/2);\n  Rect UM(3*frame.cols/2, 0, frame.cols/2, frame.rows/2);\n  //Rect UR(2*frame.cols, 0, frame.cols/2, frame.rows/2);\n  Rect BL(frame.cols, frame.rows/2, frame.cols/2, frame.rows/2);\n  Rect BM(3*frame.cols/2, frame.rows/2, frame.cols/2, frame.rows/2);\n  //Rect BR(2*frame.cols, frame.rows/2, frame.cols/2, frame.rows/2);\n\n  Mat frameShow = frame.clone();\n  rectangle(frameShow, goalArea, Scalar(0, 0, 255));\n  //rectangle(frameShow, bigGoal, Scalar(255, 0, 0));\n\n  Mat mosseg;\n  cvtColor(correlationResult, mosseg, CV_GRAY2BGR);\n\n  circle(frameShow, Point(goalArea.x + goalArea.width/2, goalArea.y + goalArea.height/2), 7, Scalar(0, 0, 255), -1);\n\n\n  if(largest == VIDEO) {\n    frameShow.convertTo(full(main), CV_32FC3);\n    normalize(full(main), full(main), 0, 1, CV_MINMAX);\n    putText(full(main), \"Original\", Point2f(5, full(main).rows-5), FONT_HERSHEY_PLAIN, 0.75*2, Scalar(0, 1, 0));\n  }\n  // else if(largest == GOAL) {\n  //   cvtColor(goal, full(main), CV_GRAY2BGR);\n  //   putText(full(main), \"g\", Point2f(5, full(main).rows-5), FONT_HERSHEY_PLAIN, 0.75*2, Scalar(0, 1, 0));\n  // }\n  else if(largest == EXACT) {\n    Mat exactBig;\n    resize(h, exactBig, Size(frame.cols, frame.rows));\n    cvtColor(exactBig, full(main), CV_GRAY2BGR);\n    putText(full(main), \"h\", Point2f(5, full(main).rows-5), FONT_HERSHEY_PLAIN, 0.75*2, Scalar(0, 1, 0));\n  }\n  else if(largest == ASEF){\n    Mat averageBig;\n    resize(average, averageBig, Size(frame.cols, frame.rows));\n    cvtColor(averageBig, full(main), CV_GRAY2BGR);\n    putText(full(main), \"MOSSE\", Point2f(5, full(main).rows-5), FONT_HERSHEY_PLAIN, 0.75*2, Scalar(0, 1, 0));\n  }\n  else if(largest == EDGES) {\n    grad.convertTo(grad, CV_32F);\n    Mat gradBig;\n    resize(grad, gradBig, Size(frame.cols, frame.rows));\n    cvtColor(gradBig, full(main), CV_GRAY2BGR);\n    normalize(full(main), full(main), 0, 1, CV_MINMAX);\n    putText(full(main), \"f\", Point2f(5, full(main).rows-5), FONT_HERSHEY_PLAIN, 0.75*2, Scalar(0, 1, 0));\n  }\n  else if(largest == CORRELATION) {\n    Mat mossegBig;\n    resize(mosseg, mossegBig, Size(frame.cols, frame.rows));\n    mossegBig.copyTo(full(main));\n    putText(full(main), \"MOSSE g* (smoothed)\", Point2f(5, full(main).rows-5), FONT_HERSHEY_PLAIN, 0.75*2, Scalar(0, 1, 0));\n  }\n  drawButton(full(main));\n  char fpsStr \[128\];\n  //sprintf(fpsStr, \"Ross is Cool\");\n  putText(full(main), fpsStr, Point2f(5, 20), FONT_HERSHEY_COMPLEX_SMALL, 0.75, Scalar(0, 1, 0));\n  putText(full(main), classLabel, Point2f(5, 60), FONT_HERSHEY_COMPLEX_SMALL, 1.5, Scalar(196,0 , 0));\n\n  Mat smallFrame, smallGoal, smallh, smallAverage, smallEdges, smallEstimatedCorrelation;\n  resize(frameShow, smallFrame, Size(frame.cols/2, frame.rows/2));\n  //resize(goal, smallGoal, Size(frame.cols/2, frame.rows/2));\n  //resize(h, smallh, Size(frame.cols/2, frame.rows/2));\n  resize(average, smallAverage, Size(frame.cols/2, frame.rows/2));\n  resize(grad, smallEdges, Size(frame.cols/2, frame.rows/2));\n  resize(mosseg, smallEstimatedCorrelation, Size(frame.cols/2, frame.rows/2));\n\n  // True video\n  smallFrame.convertTo(full(UL), CV_32FC3);\n  normalize(full(UL), full(UL), 0, 1, CV_MINMAX);\n  putText(full(UL), \"Original\", Point2f(5, full(UL).rows-5), FONT_HERSHEY_COMPLEX_SMALL, 0.75, Scalar(0, 1, 0));\n  // Edges\n  smallEdges.convertTo(smallEdges, CV_32F);\n  cvtColor(smallEdges, full(BL), CV_GRAY2BGR);\n  normalize(full(BL), full(BL), 0, 1, CV_MINMAX);\n  putText(full(BL), \"f\", Point2f(5, full(BL).rows-5), FONT_HERSHEY_COMPLEX_SMALL, 0.75, Scalar(0, 1, 0));\n\n  // Exact h\n  // cvtColor(smallh, full(UM), CV_GRAY2BGR);\n  // putText(full(UM), \"h\", Point2f(5, full(UM).rows-5), FONT_HERSHEY_COMPLEX_SMALL, 0.75, Scalar(0, 1, 0));\n\n  // Average h\n  cvtColor(smallAverage, full(BM), CV_GRAY2BGR);\n  putText(full(BM), \"MOSSE\", Point2f(5, full(BM).rows-5), FONT_HERSHEY_COMPLEX_SMALL, 0.75, Scalar(0, 1, 0));\n\n  // goal\n  // cvtColor(smallGoal, full(UR), CV_GRAY2BGR);\n  // putText(full(UR), \"g\", Point2f(5, full(UR).rows-5), FONT_HERSHEY_COMPLEX_SMALL, 0.75, Scalar(0, 1, 0));\n\n  // Correlation\n  smallEstimatedCorrelation.copyTo(full(UM));\n  putText(full(UM), \"MOSSE g* (smoothed)\", Point2f(5, full(UM).rows-5), FONT_HERSHEY_COMPLEX_SMALL, 0.75, Scalar(0, 1, 0));\n\n  if(largest == VIDEO) {\n    rectangle(\n      full(UL),\n      Point(1, 1),\n      Point(frame.cols/2-1, frame.rows/2-1),\n      Scalar(0, 255, 0)\n    );\n  }\n  // else if(largest == GOAL) {\n  //   rectangle(\n  //     full(UR),\n  //     Point(1, 1),\n  //     Point(frame.cols/2-1, frame.rows/2-1),\n  //     Scalar(0, 255, 0)\n  //   );\n  // }\n  // else if(largest == EXACT) {\n  //   rectangle(\n  //     full(UM),\n  //     Point(1, 1),\n  //     Point(frame.cols/2-1, frame.rows/2-1),\n  //     Scalar(0, 255, 0)\n  //   );\n  // }\n  else if(largest == ASEF){\n    rectangle(\n      full(BM),\n      Point(1, 1),\n      Point(frame.cols/2-1, frame.rows/2-1),\n      Scalar(0, 255, 0)\n    );\n  }\n  else if(largest == EDGES) {\n    rectangle(\n      full(BL),\n      Point(1, 1),\n      Point(frame.cols/2-1, frame.rows/2-1),\n      Scalar(0, 255, 0)\n    );\n  }\n  else if(largest == CORRELATION) {\n    rectangle(\n      full(UM),\n      Point(1, 1),\n      Point(frame.cols/2-1, frame.rows/2-1),\n      Scalar(0, 255, 0)\n    );\n  }\n\n  imshow(mainWindowName, full);\n}\n\nvoid frameDisplay() {\n  update();\n  draw();\n}\n\nMat getFeatureVectors(int, void*)\n{\n  int width = 128;\n  int height = 128;\n  Ptr<DescriptorExtractor> temp = SURF::create();\n\n  int x = goalArea.x - ((width - goalArea.width)/2);\n  int y = goalArea.y - ((height - goalArea.height)/2);\n  if(x + width >= frame.cols)\n    x = frame.cols - width -1;\n  if(y + height >= frame.rows)\n    y = frame.rows - height - 1;\n\n  Rect roi(max(x, 0), max(y,0), width, height);\n\n  Mat features = frame(roi).clone();\n  Mat descriptors;\n  Ptr<SURF> detector = SURF::create(hessian);\n  detector -> detect(features, keypoints);\n  temp -> compute(features, keypoints, descriptors);\n  //cout << descriptors.size() << endl;\n  return descriptors;\n}\nint handleNames(vector<string> &classNames, string newClass)\n{\n  unsigned int index;\n  for(index = 0; index < classNames.size(); index++)\n  {\n    if(classNames\[index\] == newClass)\n    {\n      return index;\n    }\n  }\n  classNames.push_back(newClass);\n  return classNames.size()-1;\n}\n\nstring getCorrectClassName(const vector<string> &classNames, const Mat &predicted)\n{\n  int counts\[classNames.size()\];\n  int index;\n  unsigned int index2;\n  int argMax = 0;\n  int max = 0;\n\n  for(index2 = 0; index2 < classNames.size(); index2++)\n  {\n    counts\[index2\] = 0;\n  }\n\n  for(index = 0; index < predicted.rows; index++)\n  {\n    counts\[(int)predicted.at<float>(index,0)\]++;\n  }\n\n  for (index2 = 0; index2 < classNames.size(); index2++)\n  {\n    if(counts\[index2\] > max)\n    {\n      max = counts\[index2\];\n      argMax = index2;\n    }\n  }\n  return classNames\[argMax\];\n}\nstring getLabel()\n{\n  string classifier = \"\";\n  Mat input = Mat::zeros(Size(1000, 200), CV_8U);\n  while(true) {\n    int fontFace = FONT_HERSHEY_PLAIN;\n    double fontScale = 5.0;\n    int thickness = 1;\n    int baseline = 0;\n    Size textSize = getTextSize(classifier, fontFace, fontScale, thickness, &baseline);\n    Point textOrg(10, (input.rows + textSize.height)/2);\n\n    input = Mat::zeros(Size(1000, 200), CV_8U);\n    putText(input, classifier, textOrg, fontFace, fontScale, Scalar(255), thickness, 8);\n    imshow(\"labeling\", input);\n    char keyboardInput = (char)waitKey(1);\n    if(isprint(keyboardInput)){\n      classifier = classifier + keyboardInput;\n    }\n    else if(keyboardInput == \'\\b\') {\n      if(classifier.size() > 0) {\n        classifier.pop_back();\n      }\n    }\n    else if(keyboardInput == 27) {\n      break;\n    }\n    else if(keyboardInput == \'\\n\' || keyboardInput == \'\\r\') {\n      break;\n    }\n  }\n  destroyWindow(\"labeling\");\n  return classifier;\n}\n\nbool readData(Mat & y, Mat & x, vector<string> &allClasses)\n{\n  ifstream fin;\n  int rowIndex = 0;\n  vector<string> classNames;\n  vector<vector<float>> inputData;\n  string line;\n\n  // clear and open file\n  fin.clear();\n  fin.open(fileName);\n\n  if(isEmpty(fin))\n  {\n    return false;\n  }\n\n  if(fin.good())\n  {\n    while(fin.good())\n    {\n      getline(fin, line);\n      parseLine(classNames, inputData, line, rowIndex);\n      rowIndex++;\n    }\n  }\n  // remove end of file stuff\n  classNames.pop_back();\n  inputData.pop_back();\n\n  y = Mat::zeros(classNames.size(), 1, CV_32F);\n  x = Mat::zeros(inputData.size(), inputData\[0\].size(), CV_32F);\n\n  for(unsigned int i = 0; i < inputData.size(); i++)\n  {\n    y.at<float>(i,0) = handleNames(allClasses, classNames\[i\]);\n    for(unsigned int j = 0; j < inputData\[i\].size(); j++)\n    {\n      x.at<float>(i,j) = inputData\[i\]\[j\];\n    }\n  }\n\n  fin.close();\n  return true;\n}\nvoid parseLine(vector<string> &classNames, vector<vector<float>> &inputData, string& line, int index)\n{\n  char temp\[100\];\n  int i = 0, tempIndex = 0;\n  vector<float> tempVal;\n  while(line\[i\] != \',\')\n  {\n    temp\[tempIndex++\] = line\[i++\];\n  }\n\n  temp\[tempIndex\] = \'\\0\';\n  classNames.push_back(temp);\n  i++;\n  tempIndex = 0;\n  while(line\[i\] != \'\\0\')\n  {\n    if(line\[i\] == \',\')\n    {\n      tempVal.push_back(atof(temp));\n      tempIndex = 0;\n    }\n    else\n    {\n      temp\[tempIndex++\] = line\[i\];\n    }\n    i++;\n  }\n  tempVal.push_back(atof(temp));\n  inputData.push_back(tempVal);\n}\nvoid writeData(Mat & y, Mat & x, vector<string> &allClasses)\n{\n  ofstream fout;\n  fout.clear();\n  fout.open(fileName, ios_base::app);\n\n  for(int i = 0; i < x.rows; i++)\n  {\n    fout << allClasses\[(int) y.at<float>(i,0)\] << \',\';\n    for(int j = 0; j < x.cols; j++)\n    {\n      if(j == x.cols - 1)\n      {\n        fout << x.at<float>(i,j) << \'\\n\';\n      }\n      else\n      {\n        fout << x.at<float>(i,j) << \',\';\n      }\n    }\n  }\n  fout.close();\n}\n\ndouble l2Norm(const Mat &one, const Mat &two)\n{\n  Mat diff = one - two;\n  double sumSqrs=0;\n  for(int i = 0; i < diff.cols; i++)\n  {\n    sumSqrs += diff.at<float>(0,i) * diff.at<float>(0,i);\n  }\n\n  return cv::sqrt(sumSqrs);\n}\n\n\nvoid removeSimilarDescriptors(Mat &newDescriptors, Mat &newLabels, Mat &descriptors, Mat &labels)\n{\n  float newLabel = newLabels.at<float>(0, 0);\n  bool broke = false;\n  Rect roi1, roi2;\n  cout  << newDescriptors.rows << \' \' << descriptors.rows  << endl;\n  for(int i = 0; i < newDescriptors.rows; i++)\n  {\n    broke = false;\n    roi1 = Rect(0, i, newDescriptors.cols, 1);\n    for(int j = 0; j < descriptors.rows; j++)\n    {\n      if(newLabel == labels.at<float>(j, 0))\n      {\n        roi2 = Rect(0, j, newDescriptors.cols, 1);\n        if( norm(newDescriptors(roi1), descriptors(roi2), NORM_L2) < 0.4)\n        {\n          broke = true;\n          break;\n        }\n      }\n    }\n    if(!broke)\n    {\n      vconcat(descriptors, newDescriptors(roi1), descriptors);\n      vconcat(labels, newLabels(Rect(0,i,1,1)), labels);\n    }\n  }\n  cout << descriptors.rows << endl;\n}\n\nbool isEmpty(ifstream &infile)\n{\n  return infile.peek() == ifstream::traits_type::eof();\n}\n
BigIm largest = VIDEO;\n
